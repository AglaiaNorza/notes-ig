% TEX program = xelatex
\documentclass[a4paper,11pt]{report}

\usepackage{./../packages/mainstyle}
\usepackage{./../packages/newboxes}
\usepackage{./../packages/titleITA}

\usepackage{graphicx}
\usepackage{bussproofs}

\setcoursename{Linguaggi di Programmazione}
\setcoursebook{non usato, integrati con le dispense del professor Cenciarelli}
\setauthorname{aglaia norza}
\setauthoremail{thisisaglaia@gmail.com}
\setauthorgithub{AglaiaNorza}

\settitlecolor{violet!35!blue!30}

\begin{document}

\makefrontpage

\tableofcontents

\chapter{Algebre induttive}

\section{I numeri naturali}

\begin{defbox}{Assiomi di Peano}{}
    L'insieme \(\mathbb{N}\) dei numeri naturali si può definire mediante i cinque \textbf{assiomi di Peano}:
    \begin{enumerate}
        \item \( 0 \in \mathbb{N} \)
        \item \( n \in  \mathbb{N} \implies \text{succ}(n) \in \mathbb{N} \)
        \item \( \not\exists n \in \mathbb{N} \ | \ 0 = \text{succ}(n) \)
        \item \( \forall n, m \ \text{succ}(n) = \text{succ}(m) \implies n = m \) \ \  {\color{gray}\small (iniettività)}
        \item \( \forall S \subseteq \mathbb{N} \ \ {\color{gray}(}0 \in S \land (n \in S \implies \text{succ}(n)\in S) \implies S = \mathbb{N}{\color{gray})}\) \ \ {\color{gray}\small (assioma di induzione)}

    \end{enumerate} 

    \begin{gbox}{assioma di induzione}
        L'assioma di induzione è necessario per evitare di equiparare ai numeri naturali insiemi che, essenzialmente, contengono una struttura come quella di \( \mathbb{N} \), e un ``qualcosa in più''. (Se all'interno dell'insieme \( A \) che stiamo considerando esiste un altro sottoinsieme proprio che rispetta gli altri assiomi, \( A \) non rispetterà il quinto assioma di Peano). 

        In più, il quinto assioma di Peano ci fornisce essenzialmente una definizione insiemistica di induzione.
    \end{gbox}

\end{defbox}


\begin{defbox}{Principio di Induzione}{}
    L'induzione può essere definita, basandosi sulle ``proprietà'' invece che 
    sull' insiemistica, come segue:

    \[
        \forall P \ \ \ \frac{P(0), \quad P(n) \implies P(n+1)}{\forall n\; P(n)}
    \]

    (la notazione equivale a \( P(0) \land P(n) \land (P(0) \land (P(n) \implies P(n+1)))  \implies \forall n P(n) \) )

\end{defbox}

Possiamo dimostrare che il quinto assioma di Peano è equivalente al principio di induzione (in quanto i concetti di ``proprietà'' e ``sottoinsieme'' sono equivalenti).

Infatti, ad ogni proprietà corrisponde un sottoinsieme i cui elementi sono esattamente quelli che soddisfano tale proprietà

Prendiamo quindi \( S = \{n \in \mathbb{N} \ | \ P(n) \text{ è vera}\}\).

In questo modo, dire \( P(0) \) equivale a dire \( 0 \in S \), e dire \( P(n) \implies P(n+1) \) equivale a dire \( n \in S \implies n+1 \in S \). E, allo stesso modo, dire \( \forall n P(n) \) equivale a dire \( \forall n, n \in S\), ovvero \(S = \mathbb{N} \).


\begin{defbox}{Numeri di von Neumann}{}
    Un altro modo di descrivere i numeri naturali viene dal matematico \textbf{John von Neumann}, che definisce i numeri naturali (``numeri di von Neumann'', \( \mathcal{N} \)) in questo modo:

    \begin{itemize}
        \item \(  0_\mathcal{N} = \emptyset\)  \ \ {\color{gray}(ovvero \( \{ \} \))}

        \item \( 1_\mathcal{N} = \{ 0_\mathcal{N}\}\) \ \ {\color{gray}(ovvero \( \{ \{\}\} \))}
        \item \( 2_\mathcal{N} = \{ 0_\mathcal{N}, 1_\mathcal{N}\}\) \ \ {\color{gray}(ovvero \( \{ \ \{\}, \{\{\}\} \ \}  \))}
        \item ...

    \end{itemize}

    I numeri di von Neumann rispettano gli assiomi di peano! (dalle dispense)

\end{defbox}

\section{Algebre, algebre induttive}

\begin{gbox}{nota: insieme unità e funzione nullaria}
    Ci è utile definire l'\textbf{insieme unità} \( \mathbb{1} = \{*\} \). \( \mathbb{1} \) è un insieme formato da un solo elemento (non ci interessa quale). 

    Un altro concetto che ci servirà è quello di \textbf{funzione costante} o \textbf{nullaria}. Una funzione nullaria \( f \) è tale che:
    \[
        f: \mathbb{1} \to A \ | \ f() = a \ \ \ \ a\in A
    \]
    (chiaramente, essa è sempre iniettiva).

    \begin{gbox}{nota}

        Una funzione nullaria su un insieme \( A \) può essere vista come un elemento di \( A \) (un qualsiasi insieme \( A \) è isomorfo a all'insieme di funzioni \( \mathbb{1}\to A \) (l'insieme di funzioni \( \mathbb{1}\to A \) ha la stessa cardinalità di \( A \)), il che ci permette di \textbf{trattare gli elementi di un insieme come funzioni}.


    \end{gbox}
\end{gbox}

\begin{defbox}{Algebra}{}
    Una \textbf{algebra} è una tupla \( (A, \Gamma) \), dove:
    \begin{itemize}
        \item \( A \) è l'insieme di riferimento (``carrier'' o ``insieme sottostante'') 
        \item \( \Gamma = \{\gamma_1, \gamma_2, \dots, \gamma_i\} \), è l'insieme di funzioni chiamate ``operazioni fondamentali'' o ``costruttori'' dell'algebra
            \subitem la segnatura dei costruttori è: \( \gamma_i:A^{\alpha_i}\times K_i \to A \).

    \end{itemize}
    \begin{gbox}{nota}
        Tra le algebre, consideriamo anche le algebre eterogenee, che prendono argomenti da insiemi diversi da \( A \).
    \end{gbox}
\end{defbox}

\begin{defbox}{Chiusura di un insieme rispetto ad un'operazione}{}
    Sia \( f: A^n \times K \to A \) un'operazione su \( A \) con parametri esterni \( K = (K_1 \times \dots \times K_m) \). 

    Un insieme \( S \subseteq A \) si dice \textbf{chiuso} rispetto ad \( f \) quando:
    \[
        a_1, \dots, a_n \in S \implies f( a_1, \dots, a_n,  k_1, \dots, k_n) \in S
    \]

    \begin{gbox}[colframe=RedViolet, colbacktitle=RedViolet]{nota!}
        Data un'operazione \( f \) che prende solo elementi esterni all'insieme \( S \) (come per esempio la funzione nullaria \ \( \mathbb{1} \to A \)), un insieme \( S \) si dice chiuso rispetto a \(f \iff \text{Im}(f) \subseteq S \)).

    \end{gbox}
\end{defbox}

\begin{defbox}{Algebra induttiva}{}
    Un'algebra \( A, \Gamma \) si dice \textbf{induttiva} quando:
    \begin{enumerate}
        \item tutte le \( \gamma_i \in \Gamma\) sono iniettive
        \item \( \forall i, j \ | \ i \neq j , \ \text{Im}(\gamma_i) \cap \text{Im}(\gamma_j) = \emptyset \), ovvero tutte le \( \gamma_i \) hanno immagini disgiunte
        \item \( \forall S\subseteq A \), se \( S \) è chiuso rispetto a tutte le \( \gamma_i \), allora \( S = A \) (ovvero il principio di induzione è rispettato)   
    \end{enumerate}
    \begin{gbox}{terza condizione}
        La terza condizione pone quindi che \( A \) sia la più piccola sotto-algebra di se stessa (ovvero non abbia sotto-algebre diverse da se stessa).
    \end{gbox}       
    \begin{gbox}{nota}
        Le tre condizioni garantiscono quindi che:
        \begin{itemize}
            \item ci sia solo un modo per costruire ogni elemento dell'algebra (\textit{i, ii})
            \item non ci siano ``elementi inutili'' (\textit{iii})
        \end{itemize}
    \end{gbox}

\end{defbox}

Vediamo come possiamo costruire \( \mathbb{N} \) come algebra induttiva.

La definizione di algebra induttiva non considera il concetto di ``elemento'', quindi, per il primo assioma di Peano, usiamo una \textit{funzione costante} \( \mathbb{0} \), con segnatura:
\[\mathbb{1} \times \mathbb{N} : x\to 0 \]

Abbiamo quindi una tupla (\( \mathbb{N}, \{\text{succ}, \mathbb{0}\} \)).

Per dimostrare che  questa tupla sia un'algebra induttiva, dobbiamo ora verificare le tre condizioni:
\begin{enumerate}
    \item tutte le \( \gamma_i \) sono induttive:
        \subitem • \( \mathbb{0} \) è necessariamente induttiva
        \subitem • succ è induttiva per il secondo assioma di Peano
    \item tutti i costruttori hanno immagini disgiunte:
        \subitem • grazie al terzo assioma di Peano \((\not\exists n \in \mathbb{N} \ | \ 0 = \text{succ}(n)) \), sappiamo che succ e \( \mathbb{0} \) hanno immagini disgiunte
    \item principio di induzione:
        \subitem • è verificato dal quinto assioma di Peano (\( 0 \in S\) corrisponde alla chiusura rispetto a \(\mathbb{0} \) e \( n \in \mathbb{N} \implies \text{succ}(n) \in \mathbb{N}\) corrisponde alla chiusura rispetto a succ)
\end{enumerate}



\begin{gbox}{alberi binari come algebre induttive}
    L'insieme degli alberi binari finiti \( (\texttt{B-trees}, \text{leaf, branch}) \), dove:
    \begin{itemize}
        \item \( \texttt{B-trees}=\{t \ | \ t \text{ è una foglia, oppure } t=\langle t_1, t_2 \rangle \text{ con } t_1, t_2 \in \texttt{B-trees}\} \)
        \item leaf: \( 1\to \texttt{B-trees} \) \ {\color{gray}(foglia)}
        \item branch: \( \texttt{B-trees} \times  \texttt{B-trees} \to  \texttt{B-trees} : (t_{sx}, t_{dx})\to t\) \ {\color{gray}(costruisce rami in modo che \( t_{sx} \) e \( t_{dx} \) siano i due sottoalberi di \( t \))}
    \end{itemize}
    è un'algebra induttiva.
    \begin{thmbox}{numero di nodi di un albero binario}{}
        Un albero binario con \( n \) foglie ha \( 2n-1 \) nodi
        \begin{proofbox}
            Si può dimostrare per induzione strutturale sui costruttori degli alberi.
            \begin{itemize}
                \item (\textbf{caso base}): la proprietà è vera per l'albero formato da una sola foglia costruito con leaf (\( \circ \)) - esso ha infatti \( n = 1 \) foglie e \( 2n-1 = 1 \) nodi.
                \item (\textbf{ipotesi induttiva}): ogni argomento dei costruttori rispetta la proprietà
                \item dobbiamo quindi verificare che il costruttore branch, dati due argomenti che rispettano la proprietà, la mantenga
                \item (\textbf{passo induttivo}): abbiamo \( t = \text{branch}(t_1, t_2)\). 
                    \subitem Sia \(n = n_1 + n_2 \) il numero di foglie di \( t \), dove le foglie di \( t_1 \) sono \( n_1 \) e quelle di \( t_2 \) sono \( n_2 \). 

                    Per ipotesi, \( t_1 \) ha \( 2n_1 - 1 \) nodi e \( t_2 \) ne ha \( 2n_2 - 1 \). Dunque, \( t \) avrà \( (2n_1 -1) + (2n_2 -1) + 1\) nodi, ovvero \( 2(n_1 + n_2) -1 = 2n - 1 \), qed.
            \end{itemize}

        \end{proofbox}

    \end{thmbox}
\end{gbox}

\begin{gbox}{liste finite come algebra induttiva}
    Dato un insieme \( A \), indichiamo con \( A-list \) l'insieme delle liste finite di elementi di \( A \).

    La tupla \( (A-list,\text{ empty, cons}) \) è un'algebra induttiva, dove:
    \begin{itemize}
        \item empty: \( \mathbb{1} \to A-list \) è la funzione costante che restituisce la \textbf{lista vuota} ``\(\langle \rangle\)''.
        \item cons: \( A \times A-list \to A-list : \text{cons}(3, \langle 5, 7 \rangle) = \langle 3, 5, 7 \rangle \) è la funzione che \textbf{costruisce una lista} aggiungendo un elemento in testa
    \end{itemize}

    Si tratta di un'algebra induttiva (notiamo che i due costruttori hanno immagini chiaramente disgiunte, sono entrambi chiusi per \( A-list \), e c'è un unico modo per costruire ogni lista).

    \begin{gbox}[colframe=Mahogany, colbacktitle=Mahogany]{liste infinite}
        Le liste infinite non possono essere un'algebra induttiva, in quanto contengono una sotto-algebra induttiva (quella delle liste finite).
    \end{gbox}
\end{gbox}

\begin{gbox}[colframe=Orchid, colbacktitle=Orchid]{i booleani come algebra non induttiva}
    Consideriamo l'algebra \( (B, \text{not}) \), dove \( B = \{0, 1\} \) e not: \(B \to B : b\to \neg b\).

    Notiamo che not è sicuramente iniettiva, e che, poiché è l'unico costruttore, anche la seconda caratteristica delle algebre induttive è rispettata.

    Notiamo però che l'algebra non rispetta il terzo requisito. Se consideriamo infatti \( \emptyset \subseteq B\), notiamo che not è chiusa rispetto ad esso. 

    Infatti, l'implicazione \( x \in \emptyset \implies \text{not}(x) \in \emptyset \) risulta vera per falsificazione della premessa (non esistono elementi in \( \emptyset \)).

    \( (\emptyset, \text{not}) \) è quindi una sotto-algebra induttiva di \( B \), che però è diversa da essa. L'implicazione della terza condizione \( (x \in \emptyset \implies \text{not}(x) \in \emptyset) \implies \emptyset = B \) è falsa, e \( (B, \text{not}) \) non è quindi un'algebra induttiva.
\end{gbox}

\section{Omomorfismi, lemma di Lambek}
\begin{gbox}{digressione - teoria delle categorie}

    Facciamo una piccola parentesi che introduce alcune nozioni di teoria delle categorie (perché è molto interessante).

    La teoria delle categorie studia in modo astratto le strutture matematiche. Una categoria  \ \( \mathcal{C} \) \ consiste di:
    \begin{itemize}
        \item  una classe ob(\( \mathcal{C} \)), i cui elementi sono chiamati \textbf{oggetti}
        \item  una classe mor(\( \mathcal{C} \)), i cui elementi sono chiamati \textbf{morfismi} (o mappe o frecce); ogni morfismo \( f: a \to b \) \ ha associati un unico oggetto sorgente \( a \) e un unico oggetto destinazione \( b \).
        \item per ogni terna di oggetti \( a, b, c \in \mathcal{C}\), è definita una funzione \( \text{mor}(b, c) \times \text{mor}(a,b) \to \text{mor}(a, c) \) chiamata \textbf{composizione di morfismi}. La composizione di \( f: b \to c \) con \( g: a \to b \) si indica con \( f \circ g: a \to c \)
            \subitem la composizione deve soddisfare i seguenti assiomi:

            (\textit{associatività}): se \( f: a \to b, \ g: b \to a \text{ e } h: c \to d\), allora \( h \circ (g \circ f) = (h \circ g) \circ f \)

            (\textit{identità}): per ogni oggetto \( x \) esiste un morfismo \( \text{id}_x : x \to x \) chiamato \textbf{morfismo identità}, tale che per ogni morfismo \( f: a \to x \) vale \( \text{id}_x \circ f = f \) e per ogni morfismo \( g : x \to b \) si ha \( g \circ \text{id}_x = g \).
    \end{itemize}

    Quindi, ogni oggetto è associato ad un unico morfismo identità. Questo permette di dare una definizione di categoria basata esclusivamente sulla classe dei morfismi: gli \textbf{oggetti vengono identificati con i corrispondenti morfismi identità}.

    All'interno della teoria delle categorie, una funzione iniettiva \( f: B \to C \) si chiama \textbf{monomorfismo}. Visto che non si possono utilizzare gli elementi per definire l'iniettività, un monomorfismo è descritto come una funzione \( f \) tale che:
    \[
        \forall A, \ \forall h, k : A \to B, \ \ \ h \circ f = k \circ f \implies h = k
    \]
    (se le funzioni \( h \) e \( k \) sono identiche ogni volta che vengono composte con \( f \), significa che non ci sono valori in \( f \) che sono assunti da più di un elemento di \( B \))
\end{gbox}

\begin{defbox}{Algebre con la stessa segnatura}{}
    Due algebre \( (A, \Gamma_A) \) e \( (B, \Gamma_B) \) hanno la stessa segnatura se, sostituendo \( A \) con \( B \) in tutte le \( \gamma_i \in \Gamma_A \), si ottiene \( \Gamma_B \).

    (La segnatura di un'algebra è data dalle segnature delle sue operazioni).
\end{defbox}

\begin{defbox}{Omomorfismo}{}
    Date due algebre con la stessa segnatura \( (A, \Gamma) \) e \( (B, \Delta = \{\delta_1, \dots, \delta_k\} ) \), un omomorfismo è una funzione \( f: A \to B \) tale che:
    \[ \forall i \ \ f(\gamma_i (a_1, \dots, a_k, k_1, \dots, k_m)) = \delta_i (f(a_1), \dots, f(a_k), k_1, \dots, k_m)\]
    {\small(con \( k_1, \dots, k_m \) parametri esterni)}

    \vspace{0.5em}

    (definizione algebrica: \( \forall a, b \in A \), date \(\circ\) operazione di \( A \) e \(\bullet\) operazione di \( B \), si ha \( f(a \circ b) = f(a) \bullet f(b) \) )
    \vspace{0.5em}

    {\small \color{gray} un omomorfismo ``rispetta le operazioni''}

    \begin{itemize}
        \item nota: la composizione di due omomorfismi è a sua volta un omomorfismo
    \end{itemize}
\end{defbox}

\begin{defbox}{Isomorfismo}{}
    Un isomorfismo è un omomorfismo biettivo.

    (Due algebre sono isomorfe (\( \cong \)) quando esiste un isomorfismo tra loro)
\end{defbox}

\begin{thmbox}{Omomorfismo tra algebre con stessa segnatura}{teo-om}
    Sia \( A \) un'algebra induttiva. Per ogni algebra \( B \) (non necessariamente induttiva) con la stessa segnatura, esiste un \textbf{unico omoformismo} \( A \to B \).

\end{thmbox}

\begin{thmbox}{Lemma di Lambek}{}
    Due algebre induttive \( A \) e \( B \) con la \textbf{stessa segnatura} sono necessariamente \textbf{isomorfe}.

    \begin{proofbox}{}
        \begin{itemize}
            \item Siccome \( A \) è un'algebra induttiva, \( \exists! \text{ omomorfismo } f : A \to B \). 
            \item Allo stesso modo, \( \exists! \text{ omomorfismo } g : B \to A \).
            \item Componendo i due omomorfismi, si ottiene un omomorfismo \( g \circ f \) con segnatura \( A \to A \). 

            \item Sappiamo che per ogni algebra esiste l'omomorfismo ``identità''.
            \item Sappiamo anche, per il teorema sopra, che esiste un unico omomorfismo \( A \to A \). 
                \subitem Ne segue necessariamente che \( g \circ a = \text{Id}_A \). {\small (lo stesso discorso si applica a \( f \circ g = \text{Id}_B \))}

            \item  \( g \circ f = \text{Id} \iff g = f^{-1}\), quindi \( g \) e \( f \) sono funzioni invertibili (= biettive) \( \implies \) \( g, f \) sono isomorfismi \( \implies A \cong B\)  

        \end{itemize}

    \end{proofbox}

\end{thmbox}


\chapter{Espressioni, linguaggi}

Definiamo un \textbf{linguaggio} \( L \) come insieme di stringhe. 

Per descrivere la sintassi di linguaggi formali (la grammatica), usiamo la BNF (Backus-Naur Form), con questa sintassi:
\[
    \texttt{<simbolo> ::= \_\_espressione\_\_}
\]

\textbf{Esempio}:
prendiamo come esempio questa grammatica:
\[
    M, N ::= 5 \ | \ 7 \ | \ M + N \ | \ M * N
\]

Le espressioni che seguono questa grammatica, sono del tipo:
\begin{itemize}
    \item ``5'' o ``7'' 
    \item un'espressione \( M+N \) o \( M*N \), in cui \( M \) e \( N \) rispettano a loro volta la grammatica
\end{itemize}

Introduciamo una funzione \( eval : L \to \mathbb{N}\), che valuta le espressioni del linguaggio:
\begin{itemize}
    \item \(eval(5) = 5\)
    \item \( eval(7) = 7 \)
    \item \( eval(M+N) = eval(M)+eval(N)\)
    \item \( eval(M*N) = eval(M)*eval(N)\)
\end{itemize}

Possiamo notare subito che \( (L, eval) \) non è un'algebra induttiva. Infatti, una stringa come ``\( 5 + 7 * 5 \)'' potrebbe essere stata generata in due modi diversi: \( (5 + 7) * 5 \) e \( 5 + (7 * 5) \). 

Possiamo però stipulare che sia induttiva. Ci basta infatti considerare \( +, \ *, \ 5\) e \( 7 \) come costruttori dell'algebra. In questo modo, \( (5 + 7) * 5 \) risulta essere un oggetto diverso da \( 5 + (7 * 5) \). È quindi possibile dimostrare che \( (L, 5, 7, +, *) \) è un'algebra induttiva.

\section{Exp}

\begin{defbox}{Linguaggio Exp}{}

    Introduciamo il linguaggio \( Exp \), con grammatica:
    \[
        M, N = k \ | \ x \ | \ M + N \ | \ let \ x = M \ in \ N
    \]
    dove:

    \begin{itemize}
        \item \( k \in Val=\{0, 1, \dots\}\) \ è una costante
        \item \( x \in Var \) è una variabile     
        \item \( M + N : Exp \times Exp \to Exp \) \ è la somma tra due espressioni
        \item \(  let : Var \times Exp \times Exp \to Exp\) \ assegna alla variabile \( x \)
            il valore \( M \) all'interno di \( N \)
    \end{itemize}

\end{defbox}

\vspace{3em}
esempi:
\begin{itemize}
    \item \( let \ x = 3 \ in \ x+x+2 \) viene valutata come \( 8 \)
    \item \( let \ x = 3 \ in \ 12 \) viene valutata come \( 12 \)
\end{itemize}

\vspace{0.5em}

Questo linguaggio causa però facilmente ambiguità. Per esempio, come valutiamo un'espressione come \( let \ x = 3 \ in \ let \ y = x \ in \ let \ x = 5 \ in \ y\) ? 

Per esplicitare la struttura del termine, è necessario legare le occorrenze delle variabili alle dichiarazioni.

\begin{defbox}{Variabili libere, legate, scope}{}
    Si dice che un'occorrenza di una variabile \( x \) è \textbf{libera} in un termine \( t \) quando non compare nel corpo di \( N \) nessun sottotermine di \( t \) nella forma \( let \ x = M \ in \ N \) (quindi, quando non le viene assegnato un valore).

    Ogni occorrenza libera di \ \( x \) \ in un termine \( N \) si dice \textbf{legata} (bound) alla dichiarazione di \( x \) nel termine \( let \ x = M \ in \ N \).

    Lo scope di una dichiarazione è l'insieme delle occorrenze libere di \( x \) in \( N \). 

    Lo \textbf{scope di una variabile} è la porzione di programma all'interno della quale una variabile può essere riferita.

\end{defbox}

Introduciamo una funzione \( free: Exp \to \mathcal{P}(Var) \), che restituisce l'insieme delle variabili libere di un'espressione:
\begin{align*}
    free(k) &= \emptyset \\
    free(x) &= \{x\} \\
    free(M+N) &= free(M) \cup free(N) \\
    free(let \ x = M \ in \ N) &= free(M) \cup (free(N) - \{x\}) 
\end{align*}

{\color{gray}(eliminiamo la \( x \), dalle variabili libere in \( N \) perché viene dichiarata dal \( let \ x \), ma non la eliminiamo da \( M \) perché  potrebbe comparire al suo interno come variabile libera, e \( M \) non fa parte dello scope di \( let \ x \) (esempio: in \( let \ x = x \ in \ x \), la \( x \) è libera perché compare libera in \( = x \) ))}

esempio: \( free(let \ x = 7 \ in \ x+y) = \{y\}\)

\subsection{Semantica operazionale}

Vogliamo introdurre nel linguaggio \( Exp \) il concetto di ``quanto fa?'' (valutazione di un'espressione).

Per farlo, abbiamo bisogno di definire un ambiente all'interno del quale valutare le espressioni (stile operazionale, ``structural operational semantics'').

\begin{defbox}{Ambienti}{}
    Un \textbf{ambiente} è una funzione parziale (funzione non necessariamente definita su tutti gli elementi del dominio) con dominio finito che associa dei valori ad un insieme finito di variabili.
    \[ E : Var \ \overset{fin}{\rightharpoonup} \ Val  \]

    Scriviamo gli ambienti come insiemi di coppie. Per esempio, l'ambiente \( E \) in cui \( z \) vale \( 3 \) e \( y \) vale \( 9 \) è indicato con \( \{(z, 3), (y, 9)\} \).

    Notiamo che, essendo \( E \) una funzione parziale, il dominio \( dom(E) \) è un sottoinsieme finito di \( Var \).

    \begin{defbox}[colframe=DarkOrchid, colbacktitle=DarkOrchid]{Insieme di ambienti}{}
        \( Env \) è definito come l'insieme degli ambienti di \( Exp \).

    \end{defbox}

\end{defbox}

\vspace{0.5em}

Gli ambienti si possono \textbf{concatenare} in questo modo:
\[ (E_1 E_2)(x) = \begin{cases}
    E_2(x) & \text{se } x\in dom(E_2) \\
    E_1(x) & \text{altrimenti}
\end{cases}
\]

Per esempio, \( \{(z, 3), (y, 9)\}\{(z, 4)\}(z) = 4 \) e \( \{(z, 3), (y, 9)\}\{(z, 4)\}(x) \) è indefinito.

\vspace{0.5em}

\begin{defbox}{Semantica operazionale di \( Exp \)}{}
    La \textbf{semantica operazionale} di \( Exp \) è una relazione
    \[ \leadsto \ \subseteq Exp \times Env \times Val\]

    in cui \( (M, E, v) \in \leadsto \iff \) il programma \( M \), nell'ambiente \( E \), produce il valore \( v \).

    \vspace{0.5em}

    Un'asserzione di appartenenza \( (M, E, v) \in \leadsto\) viene chiamata \textit{giudizio operazionale}, e si scrive
    \[ E \vdash M \leadsto v \]


    Questa relazione è definita dalle seguenti \textbf{regole}:
    \[ E \vdash k \leadsto k  \ \ \ [ const ] \] 
    \vspace{-1.5em}
    {\small\color{gray}\[ (\text{in ogni ambiente } E \text{, una costante } k \text{ vale } k )\]}
    \vspace{-1em}
    \[ E \vdash x \leadsto v  \ \ \ \text{ se }  v = E(x) \ \ \ [ var ] \]
    \vspace{-1.5em}
    {\small\color{gray}\[ (\text{una variabile } x \text{ vale } v \text{ se la funzione ambiente } E(x) \text{ le associa il valore } v )\]}
    \vspace{-0.5em}
    \[
        \frac{
            E \vdash M \leadsto v \quad E \vdash N \leadsto w
        }{
            E \vdash M + N \leadsto v + w
        }
        \ \ \ [plus]
    \]
    {\small\color{gray}\[ (\text{se nello stesso ambiente } M \text{ vale } v \text{ e } N \text{ vale } w, \ M+N \text{ varrà } u+w)\]}
    \vspace{-0.5em}
    \[
        \frac{
            E \vdash M \leadsto v_1 \quad E\{(x, v_1)\} \vdash N \leadsto v_2
        }{
            E \vdash \ let \ x = M \ in \ N \leadsto v_2
        }
        \ \ \  [let]
    \]

    {\color{gray}(essenzialmente, per valutare una \( let \), si:
        \begin{itemize}
            \item valuta \( M\) \ \ (\( E \vdash M \leadsto v_1) \)
            \item si ``associa'' il risultato \( v_1 \) a \( x \), concatenando \( (x, v_1) \) all'ambiente
            \item e si valuta \( N \) nel nuovo ambiente)
    \end{itemize} }
\end{defbox}

Notiamo che si utilizza la relazione \( \leadsto \) e non una una funzione \( Exp \times Env \to Val \), perché si potrebbe avere più di un risultato (per esempio nel caso del multithreading, in cui un diverso ordine di esecuzione di un programma dà output diversi), o anche nessun risultato (per esempio nel caso in cui in \( Exp \) compare una variabile \( x \), che però \( Env \) non definisce), entrambi casi non accettati dalla definizione di funzione. \\[6pt]


\begin{gbox}{precedenza}
    Introduciamo un concetto di ``precedenza'' nella valutazione di un'espressione potenzialmente ambigua;
    un'espressione del tipo:
    \[ let \ \ x = 3 \ \ in \ \ let \ \ x = \ let \ \ y = 2 \ \ in \ \ x+y \ \ in \ \ x+7 + x \]

    in assenza di parentesi, va valutata ``partendo dall'interno''.

    Corrisponde quindi a 

    \[ let \ \ {\color{purple}x}= {\color{purple} 3} \ \ in \ \ [ \ let \ \ {\color{ForestGreen}x}= \ (let \ \ {\color{RoyalPurple}y} = {\color{RoyalPurple} 2} \ \ in \ \ {\color{purple} x}+{\color{RoyalPurple} y}) \ \ in \ \ {\color{ForestGreen}x}+7 \ ] + {\color{purple}x} \]
    E si ha quindi che:
    \begin{itemize}
        \item la \( \color{purple} x \) in \( {\color{purple}x}+y \) e quella finale (\( + \color{purple} x \)) sono quelle valutate dal \( let \) iniziale
        \item il valore della \( \color{ForestGreen} x \) in \( x+7 \) è invece dato dal risultato di \(let \ x =  (let \  y = {\color{purple} 2} \ \ in \ \ {\color{purple} x}+{\color{purple} y})  \)
    \end{itemize}

\end{gbox}

Facciamo un esempio di valutazione di un'espressione:


\begin{center}
\includegraphics[width=1\textwidth]{img/valutazione-es}
\end{center}
(copierò appena ho tempo...)

\section{Valutazioni Eager e Lazy}
La valutazione utilizzata fino a questo momento viene definita
\textbf{eager}, in quanto valuta \( N \) immediatamente (anche nel caso in cui non servisse veramente valutarlo).

Se infatti consideriamo un caso del tipo
\( let \ = \text{ [espressione lunghissima] } \ in \ 7 \), notiamo immediatamente che la valutazione di \( N \) non è necessaria, in quanto l'espressione farà, in ogni caso, \( 7 \).

Introduciamo quindi un approccio \textbf{lazy}, che consiste nel valutare un termine solo quando (e se) ce n'è veramente bisogno. 

La valutazione di \( N \) in un termine del tipo \( let \ x = \ N \ in \ M \) viene rimandata, quindi, al momento in cui ad \( M \) (eventualmente) servirà il suo valore.

\begin{defbox}{Regole della semantica lazy di \(Exp\)}{}
   \begin{itemize}
    \item I termini non valutati subito vengono conservati in un ``ambiente pigro'' - estendiamo quindi \( Env \) in questo modo:
   \[ Env = Var \overset{fin}{\rightharpoonup} Exp \]
   (gli ambienti contengono ora anche i termini non valutati, quindi non possiamo avere come codominio \( Val \))

\item la nuova regola per le variabili è:
    \[ \frac{E\vdash M \leadsto v}{E\vdash x \leadsto v} \ \ \text{se } E(x)=M\]

\item la nuova regola per il \( let \) è:
    \[ \frac{E(x, M)\vdash N \leadsto v}{E \vdash let \ x = M \ in \ N \leadsto v} \]

   \end{itemize}
\end{defbox}

Notiamo che però non sempre l'approccio lazy è più veloce: per esempio, per l'espressione \( let \ x = N \ in \ (x+x+x) \), \( N \) viene calcolata \( 3 \) volte con l'approccio lazy e una sola con quello eager.


Mettiamo i due approcci a confronto sull'espressione \[ let \ x = 2 \ in \ let \ y = x \ in \ let \ x = 7 \ in \ y \leadsto 3 \]
  
  \begin{itemize}
      \item \textbf{approccio eager}:
  \end{itemize}
  \vspace{-1em}
\begin{prooftree}
\AxiomC{$(x,2) \vdash x \rightsquigarrow 2$}
\AxiomC{$(x,2) \vdash 1 \rightsquigarrow 1$}
\BinaryInfC{$(x,2) \vdash x + 1 \rightsquigarrow 3$}
\AxiomC{$(x,2)(y,3) \vdash 7 \rightsquigarrow 7$}
\AxiomC{$(x,2)(y,3)(x,7) \vdash y \rightsquigarrow 3$}
\BinaryInfC{$(x,2)(y,3) \vdash \text{let } x = 7 \text{ in } y \rightsquigarrow 3$}
\BinaryInfC{$(x,2) \vdash \text{let } y = x + 1 \text{ in let } x = 7 \text{ in } y \rightsquigarrow 3$}
\UnaryInfC{$\emptyset \vdash \text{let } x = 2 \text{ in let } y = x + 1 \text{ in let } x = 7 \text{ in } y \rightsquigarrow 3$}
\end{prooftree}

  \begin{itemize}
      \item \textbf{approccio lazy}:
  \end{itemize}
  \vspace{-1em}

\begin{prooftree}
\AxiomC{$(x,2)(y,x+1)(x,7) \vdash 7 \rightsquigarrow 7$}
\UnaryInfC{$(x,2)(y,x+1)(x,7) \vdash x \rightsquigarrow 7$}
\AxiomC{$(x,2)(y,x+1)(x,7) \vdash 1 \rightsquigarrow 1$}
\BinaryInfC{$(x,2)(y,x+1)(x,7) \vdash x + 1 \rightsquigarrow 8$}
\UnaryInfC{$(x,2)(y,x+1)(x,7) \vdash y \rightsquigarrow 8$}
\UnaryInfC{$(x,2)(y,x+1) \ \text{let } x = 7 \text{ in } y \rightsquigarrow 8$}
\UnaryInfC{$(x,2) \vdash \text{let } y = x + 1 \text{ in let } x = 7 \text{ in } y \rightsquigarrow 8$}
\UnaryInfC{$\emptyset \vdash \text{let } x = 2 \text{ in let } y = x + 1 \text{ in let } x = 7 \text{ in } y \rightsquigarrow 8$}
\end{prooftree}

Notiamo che i due approcci ci danno risultati diversi.

Ciò è causato non dall'approccio valutativo, bensì dallo \textbf{scoping} utilizzato. Abbiamo infatti utilizzato quello che viene definito "scoping dinamico", il che ha causato problemi perché, in \( Exp \), lazy dinamico e eager non sono equivalenti.

\pagebreak

\section{Scoping}

\begin{defbox}[colframe=BrightGreen, colback=BrightGreenLight, colbacktitle=BrightGreen]{Scoping}{}
    Lo \textbf{scoping} di un linguaggio è l'insieme di regole che determinano la visibilità di una variabile all'interno di un programma (ossia che consentono di associare una variabile a ciascun riferimento {\small \color{gray} (= uso della variabile mediante un identificatore)}).
\end{defbox}

\begin{defbox}{Scoping statico}{}
    Quando si usa lo \textbf{scoping statico}, i riferimenti ad una variabile sono risolti in base alla \textbf{struttura sintattica} del programma (tipicamente in base ad una dichiarazione).

    Ovvero, durante la valutazione viene utilizzato l'\textbf{ambiente definito a tempo di interpretazione} (e non di valutazione).
\end{defbox}

\begin{defbox}{Scoping dinamico}{}
    Quando si usa lo \textbf{scoping dinamico}, i riferimenti ad una variabile sono risolti in base allo \textbf{stato di esecuzione} del programma (per esempio, una dichiarazione estende il suo effetto fino a che non si incontra un altra dichiarazione di variabile con lo stesso nome).

    Quindi, durante la valutazione viene utilizzato l'\textbf{ambiente definito a tempo di valutazione} stesso.
\end{defbox}

Dobbiamo quindi mantenere, oltre alle espressioni rimaste da valutare, anche gli ambienti in cui valutarle.

Per farlo, estendiamo nuovamente \( Env \) in questo modo:
\[ Env_{LS} = Var \overset{fin}{\rightharpoonup} (Exp \times Env_{LS}) \]


\begin{defbox}{Regole della semantica lazy statica di \(Exp\)}{}

   \begin{itemize}
    \item I termini non valutati subito vengono conservati in un ``ambiente pigro'' - estendiamo quindi \( Env \) in questo modo:
   \[ Env = Var \overset{fin}{\rightharpoonup} Exp \]
   (gli ambienti contengono ora anche i termini non valutati, quindi non possiamo avere come codominio \( Val \))

\item la nuova regola per le variabili è:
    \[ \frac{E'\vdash M \leadsto v}{E\vdash x \leadsto v} \ \ \text{se } E(x)=(M, E')\]

\item la nuova regola per il \( let \) è:
    \[ \frac{E(x, M, E)\vdash N \leadsto v}{E \vdash let \ x = M \ in \ N \leadsto v} \]

   \end{itemize}
\end{defbox}

Valutiamo la stessa espressione anche con questo approccio:

\begin{prooftree}
\AxiomC{$(x,2,\emptyset) \vdash x\leadsto 2$}
\AxiomC{$(x,2,\emptyset) \vdash 1 \leadsto 1 $}
\BinaryInfC{$(x,2, \emptyset)\vdash x + 1 \rightsquigarrow 3$}
\UnaryInfC{${\color{blue}E}(x, 7,E) \vdash y \rightsquigarrow 3$}
\UnaryInfC{${\color{blue}(x,2, \emptyset)(y,x+1, (x, 2, \emptyset)}\vdash \ \text{let } x = 7 \text{ in } y \rightsquigarrow 3$}
\UnaryInfC{$(x,2,\emptyset) \vdash \text{let } y = x + 1 \text{ in let } x = 7 \text{ in } y \rightsquigarrow 3$}
\UnaryInfC{$\emptyset \vdash \text{let } x = 2 \text{ in let } y = x + 1 \text{ in let } x = 7 \text{ in } y \rightsquigarrow 3$}
\end{prooftree}

In \( Exp \) non c'è, invece, differenza tra eager statico e eager dinamico.

\begin{gbox}{}
   Essenzialmente, in \( Exp \):
   \vspace{-1em}
\begin{center}
\begin{tabular}{c|c|c}
     & \textbf{statico} & \textbf{dinamico} \\ \hline
\textbf{lazy} & equiv & non equiv \\ \hline
\textbf{eager}& \multicolumn{2}{c}{equiv (e uguali tra loro)} \\
\end{tabular}
\end{center} 
\end{gbox}

\begin{gbox}[colframe=DeepGrey, colback=DeepGreyLight, colbacktitle=DeepGrey]{``commutatività'' in \( Exp \)}
    In \( Exp \), si ha:
    \[ let \ x = (let \ y  = M \ in \ N) \ in \ L \not\equiv \ let \ y = M \ in \ let \ x = N \ in \ L \]
\begin{itemize}
    \item nella prima espressione, \( y \) è definita solo all'interno di \( N \)
    \item nella seconda, è definita prima, ed è quindi visibile anche in \( L \)
    \item quindi, le due espressioni sono equivalenti solo se \( y \) non compare libera {\small \color{gray}(non ri-definita)} in \( L \)
\end{itemize}
\end{gbox}

\subsection{Riassunto delle regole in \( Exp \)}

\begin{gbox}[colframe=DeepGreen, colback=DeepGreenLight, colbacktitle=DeepGreen]{eager}
        \[ E \vdash k \leadsto k  \ \ \ [ const ] \] 
        \vspace{-2.5em}

    \[ E \vdash x \leadsto v  \ \ \ \text{ se }  v = E(x) \ \ \ [ var ] \]
        \vspace{-2em}

    \[
        \frac{
            E \vdash M \leadsto v \quad E \vdash N \leadsto w
        }{
            E \vdash M + N \leadsto v + w
        }
        \ \ \ [plus]
    \]



    \[
        \frac{
            E \vdash M \leadsto v_1 \quad E\{(x, v_1)\} \vdash N \leadsto v_2
        }{
            E \vdash \ let \ x = M \ in \ N \leadsto v_2
        }
        \ \ \  [let]
    \]


\end{gbox}


\begin{gbox}[colframe=DeepTeal, colback=DeepTealLight, colbacktitle=DeepTeal]{lazy statico}
    
    \[ \frac{E'\vdash M \leadsto v}{E\vdash x \leadsto v} \ \ \text{se } E(x)=(M, E') \ \ \ [var] \]

    \[ \frac{E(x, M, E)\vdash N \leadsto v}{E \vdash let \ x = M \ in \ N \leadsto v} \ \ \ [let]\]


\end{gbox}


\begin{gbox}[colframe=BlueGray, colback=BlueGrayLight, colbacktitle=BlueGray]{(lazy dinamico)}
    \[ \frac{E\vdash M \leadsto v}{E\vdash x \leadsto v} \ \ \text{se } E(x)=M \ \ \ [var]\]

    \[ \frac{E(x, M)\vdash N \leadsto v}{E \vdash let \ x = M \ in \ N \leadsto v} \ \ \ [let] \]
\end{gbox}


\todo{esercizi}

\pagebreak

\section{Fun}
Introduciamo un nuovo linguaggio, \( Fun \), che estende \( Exp \) con la nozione di \textbf{funzione}.

\begin{defbox}{\( Fun \)}{}

La grammatica di \( Fun \) è:
    \[
        M, N = k \ | \ x \ | \ M + N \ | \ let \ x = M \ in \ N \ | \ fn \ x \implies M \ | \ MN
    \]
    dove:
    \begin{itemize}
        \item le regole presenti in \( Exp \) (1-4) rimangono invariate, con gli appropriati cambi di dominio (es. \( let : Var \times Fun \times Fun \to Fun \))
        \item \( fn : Var \times Fun \to Fun \) \ è una \textbf{funzione} (anonima) con parametro \( x \)     
        \begin{itemize}
            \item una funzione \( fn \ x \implies M \) si può rappresentare in maniera alternativa attraverso la sua \textbf{chiusura}, \( (x, M)\in Var \times Fun \)
        \end{itemize}
    \item \( \cdot : Fun \times Fun \to Fun \) \ è l'\textbf{applicazione di funzioni} 
        \subitem il termine sinistro (che, perché l'espressione abbia semanticamente senso, deve necessariamente essere una funzione) viene applicato al termine destro (quindi \( MN=M(N) \))
    \item l'insieme \( Val \) non coincide più con quello delle costanti, ma corrisponde a \( Var \cup (Var \times Fun) \) (variabili \( \cup \) chiusure)
    \end{itemize}

\end{defbox}

Quindi, per esempio:
\begin{itemize}
    \item \( (fn \ x \implies x+1) \ 5 = 6\) \ \ (la funzione \( x+1 \) è applicata all'argomento \( 6 \))
    \item \( (fn \ x \implies x \ 5)(fn \ y \implies y + 1) = 6 \)
        \subitem la funzione prende in input una funzione (in questo caso ``successore''), e la applica a \( 5 \)
    \item \( (fn \ x \implies (fn \ y \implies y \ x)) \ 3 \ (fn \ z \implies z+1) \ = 4\)
        \subitem è una funzione che, presa in input un'altra funzione, la applica ad \( x \) - le passiamo la funzione ``successore'', che, applicata a \( 3 \), dà \( 4 \).
    \item un'applicazione del tipo \( fn \ x \implies x \ 10 \) ``non ha semantica'' (non è valutabile), in quanto \( 10 \) non è una funzione e non si può applicare a \( x \)
\end{itemize}

\begin{gbox}{precedenza di \( apply \)}
    la precedenza nell'applicazione è a sinistra
    \[ MNL \equiv (MN)L \]
\end{gbox}

\begin{defbox}[colback=DeepGreenLight, colframe=DeepGreen, colbacktitle=DeepGreen]{Semantica eager dinamica di \( Fun \)}{}
    
\begin{center}
    [\( fn \) dinamico eager]
\end{center}
\vspace{-1em}
    \[  E \vdash fn \ x \implies M \leadsto (x, M) \]

\begin{center}
    [\( apply \) dinamico eager]
\end{center}
\vspace{-2.3em}
\begin{prooftree}
\AxiomC{$E \vdash M \leadsto (x, M')$}
\AxiomC{$E\vdash N \leadsto v$}
\AxiomC{$E (x, v)\vdash M' \leadsto v'$} 
\TrinaryInfC{$E \vdash MN \leadsto v'$ }
\end{prooftree}
    
\end{defbox}

Esempio:
\todo{esempio}

\begin{defbox}[colback=DeepGreenLight, colframe=DeepGreen, colbacktitle=DeepGreen]{Semantica eager statica di \( Fun \)}{}
    \begin{center}
    [\( fn \) statico eager]
\end{center}
\vspace{-1em}
    \[  E \vdash fn \ x \implies M \leadsto (x, M, E)\]

\begin{center}
    [\( apply \) statico eager]
\end{center}
\vspace{-2.3em}
\begin{prooftree}
\AxiomC{$E \vdash M \leadsto (x, M', E')$}
\AxiomC{$E\vdash N \leadsto v$}
\AxiomC{$E' (x, v)\vdash M' \leadsto v'$} 
\TrinaryInfC{$E \vdash MN \leadsto v'$ }
\end{prooftree}

\end{defbox}


\begin{lemmabox}{Eager dinamico e statico in \( Fun \)}{}
    (Al contrario di \( Exp \)), si ha che:
    \[ Fun \text{ eager dinamico} \not\equiv \ Fun \text{ eager statico } \]
\end{lemmabox}



\begin{defbox}{Semantica lazy dinamica di \( Fun \)}{}

    \begin{center}
        [\( fn \) lazy statico]
    \end{center}
    \vspace{-1em}
    \[ E \vdash fn \ x \implies M \leadsto (x, M) \]


    \begin{center}
        [\( apply \) lazy statico]
    \end{center}
    \vspace{-2em}
    \begin{prooftree}
        \AxiomC{\( E\vdash M \leadsto (x, M') \)}
        \AxiomC{\( E(x, N)\vdash M' \leadsto v \)}
        \BinaryInfC{\( E\vdash M \ N \leadsto v \)}
    \end{prooftree}
\end{defbox}
\begin{defbox}{Semantica lazy statica di \( Fun \)}{}

    \begin{center}
        [\( fn \) lazy statico]
    \end{center}
    \vspace{-1em}
    \[ E \vdash fn \ x \implies M \leadsto (x, (M, E)) \]


    \begin{center}
        [\( apply \) lazy statico]
    \end{center}
    \vspace{-2em}
    \begin{prooftree}
        \AxiomC{\( E\vdash M \leadsto (x, M', E') \)}
        \AxiomC{\( E'(x, (N, E))\vdash M' \leadsto v \)}
        \BinaryInfC{\( E\vdash M \ N \leadsto v \)}
    \end{prooftree}
\end{defbox}

Introduciamo un termine interessante - \( (fn \ x \implies xx)(fn \ x \implies xx) \) - e tentiamo di valutarlo con un approccio eager (dinamico)

{\tiny
\begin{prooftree}
  \AxiomC{\(  \emptyset \vdash fn \ x \implies xx \leadsto (x, xx) \)}
  \AxiomC{\( \emptyset \vdash fn \ x \implies xx \leadsto (x, xx)  \)}
  \AxiomC{\(  (x, (x,xx))\vdash  x \leadsto (x, xx)\)}
  \AxiomC{\(  (x, (x,xx))\vdash  x \leadsto (x, xx)\)}
  \AxiomC{\((x, (x,xx))\vdash  xx \leadsto \)}
  \TrinaryInfC{\( (x, (x,xx))\vdash  xx \leadsto \)}
  \TrinaryInfC{\( \emptyset \vdash (fn \ x \implies xx)(fn \ x \implies xx) \)}
\end{prooftree}
}

Notiamo che il termine va in loop - infatti, si ha che, per valutare \((x, (x,xx))\vdash  xx \), bisogna prima valutare \((x, (x,xx))\vdash  xx \) (se stesso).

\begin{gbox}{Termine \( \omega \)}
    Chiamiamo \( \omega \) termine appena introdotto:
    \[ \omega =  (fn \ x \implies xx)(fn \ x \implies xx) \]

    
\end{gbox}

Qui emerge una grande differenza tra valutazione eager e lazy: con un approccio eager, un'espressione del tipo \( let \ x = \omega \ in \ 7 \) va in loop, mentre con una valutazione lazy viene valutata correttamente.


\begin{defbox}{Curryficazione}{}

    La \textbf{curryficazione} (o ``applicazione parziale'') è la tecnica che consiste nel tradurre una funzione che accetta più argomenti in una sequenza di famiglie di funzioni, ciascuna delle quali accetta un singolo argomento.


    Partendo da una funzione \( f: (X \times Y) \to Z\) che prende due argomenti, la sua curryficazione tratta il primo argomento come un parametro, e crea una famiglia di funzioni \( f_x : Y \to Z \) tale che, per ogni \( x \in X  \), c'è esattamente una funzione \( f_x \) tale che \( \forall \ y \in Y , \  f_x(y)=f(x,y)\).
    \[ \text{curry}: [ \ (X \times Y) \to Z \ ] \to [ \ X \to (Y \to Z) \ ]\]
    \[ f \mapsto h : f(x, y) = h(x)(y) \]


Si trasforma quindi una funzione che prende due argomenti in una funzione ad un argomento che ritorna un'altra funzione t.c. \( curry((f))(x)(y) = f(x, y) \).

(Il processo inverso prende il nome di \textbf{decurryficazione}).

\end{defbox}

\begin{gbox}[colback=DeepGreenLight, colframe=DeepGreen, colbacktitle=DeepGreen]{Curryficazione in \( Fun \)}
    La curryficazione ci permette di introdurre una notazione contratta del \( fn \):
    \[ [ \ fn \ x y \implies \ ] \equiv [ \ fn \ x \implies ( fn \ y \implies ) \ ]\]

    Possiamo così introdurre \textbf{funzioni a più argomenti} all'interno del linguaggio \( Fun \).

\end{gbox}

\section{Semantica del lambda calcolo}
La semantica di \( Fun \) si può esprimere in termini del linguaggio (più elementare) del lambda calcolo.


\begin{lstlisting}
val zero = fn x => fn x => y;
\end{lstlisting}
è il false di church


\begin{lstlisting}
fun zero x y = y;
\end{lstlisting}

operatore di ricorsione = linguaggio inconsistente type-wise

\begin{lstlisting}
    val succ = fn w => (fn x => fn y => x(w x y));
\end{lstlisting}
(faccio w volte x su y, più un'altra volta ( x())

\begin{lstlisting}
    val plus = fn u => fn v => (u succ v);
    val plus u v x y = v x(u x y)
\end{lstlisting}
in cui u, v numeri di church, x funzione, y da cui parto
x(u x y) succ

\begin{lstlisting}
    val times = fn u => fn v => (u (fn z => (plus z v)) zero);
\end{lstlisting}
passo a u la funzione che fa u volte la funzione che sommma v, a partire da zero (di church)

\begin{lemmabox}{Eager dinamico e statico in \( Fun \)}{}
    (Al contrario di \( Exp \)), si ha che:
    \[ Fun \text{ eager dinamico} \not\equiv \ Fun \text{ eager statico } \]
\end{lemmabox}


\begin{prooftree}
  \AxiomC{$Y$}
  \AxiomC{$X$}
  \AxiomC{$A$}
  \AxiomC{$B$}
  \AxiomC{$C$}
  \TrinaryInfC{$Z$}
  \TrinaryInfC{$F$}
\end{prooftree}

\begin{defbox}{Semantica operazionale di \( Fun \) lazy dinamico}{}

    \begin{center}
        [\( fn \) lazy statico]
    \end{center}
    \vspace{-1em}
    \[ E \vdash fn \ x \implies M \leadsto (x, M) \]


    \begin{center}
        [\( apply \) lazy statico]
    \end{center}
    \vspace{-2em}
    \begin{prooftree}
        \AxiomC{\( E\vdash M \leadsto (x, M') \)}
        \AxiomC{\( E(x, N)\vdash M' \leadsto v \)}
        \BinaryInfC{\( E\vdash M \ N \leadsto v \)}
    \end{prooftree}
\end{defbox}
\begin{defbox}{Semantica operazionale di \( Fun \) lazy statico}{}

    \begin{center}
        [\( fn \) lazy statico]
    \end{center}
    \vspace{-1em}
    \[ E \vdash fn \ x \implies M \leadsto (x, (M, E)) \]


    \begin{center}
        [\( apply \) lazy statico]
    \end{center}
    \vspace{-2em}
    \begin{prooftree}
        \AxiomC{\( E\vdash M \leadsto (x, M', E') \)}
        \AxiomC{\( E'(x, (N, E))\vdash M' \leadsto v \)}
        \BinaryInfC{\( E\vdash M \ N \leadsto v \)}
    \end{prooftree}
\end{defbox}

\begin{defbox}{Curryficazione}{}

    La \textbf{curryficazione} è la tecnica che consiste nel tradurre una funzione che accetta più argomenti in una sequenza di famiglie di funzioni, ciascuna delle quali accetta un singolo argomento.


    Partendo da una funzione \( f: (X \times Y) \to Z\) che prende due argomenti, la sua curryficazione tratta il primo argomento come un parametro, e crea una famiglia di funzioni \( f_x : Y \to Z \) tale che, per ogni \( x \in X  \), c'è esattamente una funzione \( f_x \) tale che \( \forall \ y \in Y , \  f_x(y)=f(x,y)\).

    \[ \text{curry}: [ \ (X \times Y) \to Z \ ] \to [ \ X \to (Y \to Z) \ ]\]
    \[ f \mapsto h : f(x, y) = h(x)(y) \]


Si trasforma quindi una funzione che prende due argomenti in una funzione ad un argomento che ritorna un'altra funzione t.c. \( curry((f))(x)(y) = f(x, y) \)

\end{defbox}

\begin{gbox}{Curryficazione in \( Fun \)}
    La curryficazione ci permette di introdurre una notazione contratta del \( fn \):
    \[ [ \ fn \ x y \implies \ ] \equiv [ \ fn \ x \implies ( fn \ y \implies ) \ ]\]

\end{gbox}

\chapter{Lambda calcolo}
\chapter{Capitolo}
\section{Numeri di Church}
Tra i diversi modi di rappresentare i numeri naturali, ci interessa presentare quello di Alonzo Church.

Per Church, il cui mondo è fatto di funzioni, un numero naturale \( n \) corrisponde all'applicare \( n \) volte una funzione \( x \) su un argomento \( y \).
 
Possiamo, per esempio, rappresentare il numero \( 2 \) ``di Church'' in \( Fun \) in questo modo:
\[ fn \  x \ y \implies x \ (x \ y) \ {\color{gray} \equiv fn \ x \implies fn \ y \implies x \ (x \ y) }\]
    (ovvero, presa una funzione \( x \) e un valore \( y \) di partenza, si applica due volte la funzione \( x \) (prima al valore stesso ``(\( x \ y \))'', e poi al risultato di questa applicazione - ``\( x( \)'' \ )))

\begin{defbox}{Numeri di Church in \( Fun \)}{}
    Più in generale, indicando con \( M^n N \) il termine \( M(M(\dots(MN)\dots)) \) {\small\color{gray}(in cui si ripete \( n \) volte \( M \))}, un numero \(c_n\) di Church si può rappresentare, con la sintassi di \( Fun \), in questo modo:
    \[ c_n \equiv fn \ x \ y \implies x^n \ y \]
\end{defbox}

Possiamo rappresentare anche altri concetti essenziali come la funzione ``successore'', la somma e il prodotto tramite numeri di Church.

\begin{defbox}{``Succ'' di Church}{}
    La funzione \textbf{successore di Church}, seguendo lo stesso ragionamento, dovrà ricevere un numero di Church \( z \) in ingresso, e restituire il numero di Church che applica \( x \) a \( y \), \( z+1 \) volte:
    \[ succ \equiv fn \ z \ x \ y \implies x\ (z \ x \ y) \]
    \[\color{gray} succ \equiv fn \ z \implies fn \ x \implies fn \ y \implies x\ (z \ x \ y) \]
    essenzialmente, dato \( z \) numero di Church di cui calcolare il successore (che vuole quindi come parametri \( x \) funzione e \( y \) valore di partenza), si applica una volta in più \( x \).

    La funzione si può scrivere anche, equivalentemente, in questo modo:
    \[ fn \ z \ x \ y \implies z \ x \ (x \ y) \]
    ``anticipando'' essenzialmente il \( +1 \) (prima si applica \( x \) una volta ``in più'', e poi le altre \( z \) volte)
\end{defbox}

Facciamo un esempio concreto:
\begin{align*}
    succ \ c_1 &= fn \ x \ y \implies x \ (c_1 \ x \ y) \\
               & = fn \ x \ y \implies x \ (( fn \ x \ y \implies xy) \ x \ y ) \\
               & = fn \ x \ y \implies x \ ( x \ y)
\end{align*}
che corrisponde al due di Church !

\begin{defbox}{Somma di Church}{}
    Seguendo lo stesso ragionamento, la \textbf{somma di Church} tra \( z\) e \( w \) è quella funzione che applica \( x\) \( w\) volte a \( y \), e passa il risultato a \( z \), (che la applicherà altre \( z \) volte).

    \[ plus \equiv fn \ z \ w \ x \ y \implies z \ x \ (w \ x \ y)\]

    (passo a \( z \), numero di Church che vuole quindi una funzione e un numero di partenza, come funzione \( x \) e come numero di partenza l'applicazione di \( x \) a partire da \( y \), \( w \) volte)

\end{defbox}
\section{Semantica del lambda calcolo}

\begin{lstlisting}
fun zero x y = y;
\end{lstlisting}

operatore di ricorsione = linguaggio inconsistente type-wise

\begin{lstlisting}
    val succ = fn w => (fn x => fn y => x(w x y));
\end{lstlisting}
(faccio w volte x su y, più un'altra volta ( x())

\begin{lstlisting}
    val plus = fn u => fn v => (u succ v);
    val plus u v x y = v x(u x y)
\end{lstlisting}
in cui u, v numeri dasdsadai church, x funzione, y da cui parto
x(u x y) succ

\begin{lstlisting}
    val times = fn u => fn v => (u (fn z => (plus z v)) zero);
\end{lstlisting}
passo a u la funzione che fa u volte la funzione che sommma v, a partire da zero (di church)

\end{document}
