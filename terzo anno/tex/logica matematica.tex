%! TEX program = xelatex
\documentclass[a4paper,11pt]{report}

\usepackage{./../packages/mainstyle}
\usepackage{./../packages/boxes}
\usepackage{./../packages/titleITA}

\usepackage{float}

\setcoursename{Logica Matematica}
\setcoursebook{tbd}
\setauthorname{aglaia norza}
\setauthoremail{thisisaglaia@gmail.com}
\setauthorgithub{AglaiaNorza}

\begin{document}

\makefrontpage

\tableofcontents

\chapter{Logica Proposizionale}

\section{Introduzione}

La logica proposizionale è un linguaggio formale con una semplice struttura sintattica basata su proposizioni elementari (atomiche) e sui seguenti connettivi logici:


\begin{itemize}
    \item \textit{Negazione} ($\neg$): inverte il valore di verità di un enunciato: se un enunciato è vero, la sua negazione è falsa, e viceversa.
    
    \item \textit{Congiunzione} ($\land$): il risultato è vero se e solo se entrambi i componenti sono veri.
    
    \item \textit{Disgiunzione} ($\lor$): il risultato è vero se almeno uno dei componenti è vero.
    
    \item \textit{Implicazione} ($\to$): rappresenta l’enunciato logico “se ... allora”. Il risultato è falso solo se il primo componente è vero e il secondo è falso. 
    
    \item \textit{Equivalenza} ($\leftrightarrow$): rappresenta l’enunciato logico “se e solo se”. 
    Il risultato è vero quando entrambi i componenti hanno lo stesso valore di verità, cioè sono entrambi veri o entrambi falsi.
\end{itemize}

Introduciamo anche il concetto di disgiunzione esclusiva o "XOR" (\( \oplus \)), il cui risultato è vero solo se gli operandi sono diversi tra di loro (uno vero e uno falso).

\begin{defbox}{Linguaggio proposizionale}{}
    Un linguaggio proposizionale è un insieme infinito \( \mathcal{L} \) di simboli detti \textbf{variabili proposizionali}, tipicamente denotato come \( \{p_i : i \in I\} \) {\color{gray} (con \( I \) "insieme di indici")}.
\end{defbox}

\begin{defbox}{Proposizione}{}
    Una \textbf{proposizione} in un linguaggio proposizionale è un elemento dell'insieme PROP così definito:
    \begin{enumerate}
        \item tutte le variabili appartengono a PROP
        \item se \( A \in \) PROP, allora \( \neg A \in \) PROP
        \item se \( A, B \in \) PROP, allora \( (A \land B), (A \lor B), (A \to B) \in \) PROP
        \item nient'altro appartiene a PROP {\color{gray}(PROP è il più piccolo insieme che contiene le variabili e soddisfa le proprietà di chiusura sui connettivi 1 e 2)}
    \end{enumerate}
\end{defbox}

Per facilitare la leggibilità delle formule, definiamo le seguenti regole di \textit{precedenza}: \( \neg \) ha precedenza su \( \land, \lor \), e questi ultimi hanno precedenza su \( \to \).

\section{Assegnamenti, tavole di verità}

    Per un linguaggio \( \mathcal{L} \), un \textbf{assegnamento} è una funzione 
    \[
        \alpha : \mathcal{L} \to \{0, 1\}
    \]

    Estendiamo \( \alpha \) ad \( \hat{\alpha} : \text{PROP} \to \{0,1\} \) in questo modo:
            \vspace{0.5em}
    \begin{itemize}
        \item \( \hat{\alpha}(\neg A) = \begin{cases}
                1 &  A = 0 \\
                0 & A = 1
            \end{cases}\)

            \vspace{0.5em}

        \item \( \hat{\alpha}(A \land B) = \begin{cases}
                1 & \hat{\alpha}(A) = \hat{\alpha}(B)  = 1 \\
                0 & altrimenti
            \end{cases}\)

            \vspace{0.5em}

        \item \( \hat{\alpha}(A \lor B) = \begin{cases}
                0 & \hat{\alpha}(A) = \hat{\alpha}(B)  = 0 \\
                1 & altrimenti
            \end{cases}\)

            \vspace{0.5em}

        \item \( \hat{\alpha}(A \to B) = \begin{cases}
                0 & \hat{\alpha}(A) = 1 \land \hat{\alpha}(B)  = 0 \\
                1 & altrimenti
        \end{cases}\)

\end{itemize}

\begin{gbox}{notazione}
    Utilizzeremo \( \alpha \) al posto di \( \hat{\alpha} \) per comodità di notazione.
\end{gbox}
 
Osserviamo che è possibile rappresentare gli assegnamenti in modo compatto utilizzando le \textbf{tavole di verità}, una presentazione tabulare della funzione di assegnamento.

        Per esempio, possiamo riscrivere la definizione di \( \alpha(\neg A) \) come segue:
        
        \[  
        \begin{array}{c | c}
            A & \neg A \\
            \hline
            0 & 1 \\
            1 & 0
                
        \end{array}
    \]

    Ogni riga di una tavola di verità corrisponde ad un assegnamento \( \alpha \).

Si noti anche che dalla definizione di \( \alpha \) segue che un'implicazione può essere vera senza che ci sia connessione causale o di significato tra antecedente e conseguente (per esempio, "se tutti i quadrati sono pari allora \( \pi \) è irrazionale"). 

In secondo luogo, segue anche che una proposizione è sempre vera se il suo antecedente è falso (il che rispecchia la pratica matematica di considerare vera a vuoto una proposizione ipotetica la cui premessa non si applica).


{\color{CadetBlue} Questo è giustificabile come segue:
\begin{itemize}
    \item vogliamo che \( (A \land B) \to B \) sia sempre vera
    \item il caso \( 1 \to 1 \) deve essere vero, perché corrisponde al caso in cui \( A \) e \( B \) sono vere; 

        il caso \( 0 \to 0  \) deve essere vero, perché corrisponde al caso in cui \( A\land B \) è falso perché \( B \) è falso; il caso \( 0 \to 0 \) deve essere vero perché corrisponde al caso in cui \( A \land B \) è falso perché \( B \) è falso; 

        il caso \( 0 \to 1 \) deve essere vero perché corrisponde al caso in cui \( A \land B \) è falso perché \( A \) è falso ma \( B \) è vero; 

        resta dunque soltanto il caso \( 1 \to 0 \), che non corrisponde a nessun caso di \( A \land B \to B \).
\end{itemize}

In più, si vuole che valga, per contrapposizione \( (A \to B)\to(\neg B \to \neg A) \).}


Osserviamo che, data \( A = p_1, p_2, \dots, p_k \) e due assegnamenti \( \alpha \) e \( \beta \) t.c.:
        \begin{align*}
            \alpha(p_1) &= \beta(p_1) \\
            &\dots \\
            \alpha(p_k) &= \beta(p_k)
        \end{align*}

        allora necessariamente \( \alpha(A) = \alpha(B) \).

        \begin{gbox}[colframe=PineGreen]{soddisfacibilità}
            Se per una formula \( A \) e un assegnamento \( \alpha \) si ha \( \alpha (A) = 1 \), si dice che ``\(A \) soddisfa \( \alpha \)'' (o ``\( A \) è vera sotto \( \alpha \)'').
            \begin{itemize}
                \item Se \( A \) ha almeno un assegnamento che la soddisfa, si dice \textbf{soddisfacibile} (\( A \in \texttt{SAT} \)).
                \item Se non esiste un assegnamento che la soddisfa, \( A \) si dice \textbf{insoddisfacibile} (\( A \in \texttt{UNSAT} \)).
                \item Se \( A \) è soddisfatta da tutti i possibili assegnamenti, si dice \textbf{tautologia} (o "verità logica") (\( A \in \texttt{TAUT} \)).
            \end{itemize}
        \end{gbox}

        Introduciamo anche alcune regole che 

        \section{Conseguenza logica}

        \begin{defbox}{Conseguenza logica}{}
            Sia \( T \) una \textit{teoria}, ossia un insieme  \( \{A_1, \dots, A_n\} \) proposizioni in un dato linguaggio proposizionale, e sia \( A \in \text{PROP}\) .

            Diciamo che \( A \) è \textbf{conseguenza logica} di \( T\) se 
            \[ \forall \alpha,\ \alpha(T)=1 \to \alpha(A)=1 \] 
            ovvero se ogni assegnamento che soddisfa \(T\) soddisfa anche \( A_{n+1} \).

            Scriviamo in tal caso \(  T \vDash A_{n+1} \), oppure \( A_1, \dots, A_n \vDash A \).
        \end{defbox}

        Si ha che:
        \begin{itemize}
            \item \(T \not\vDash A\) \ significa che \ \( \exists \alpha \) \ t.c. \ \( \alpha(T) = 1 \land \alpha(A) = 0 \)
            \item \( \emptyset \vDash A \) \ o, equivalentemente \ \( \vDash A \iff A\) è una tautologia
        \end{itemize}

        \begin{lemmabox}{Equivalenze}{}
            \begin{enumerate}
                \item \( T \vDash A \)
                \item \( \vDash (A_1 \land \dots \land A_n) \to A \)
                \item \( (A_1 \land \dots \land A_n) \in \texttt{UNSAT}\) 
            \end{enumerate}

                    sono equivalenti.
            
        \end{lemmabox}

        \section{Completezza funzionale}
        \todo{da fare}

        \section{Forme normali}

        \begin{gbox}{notazione}
            Chiamiamo "letterale" una variabile proposizionale o una negazione di una variabile proposizionale
        \end{gbox}

        È utile individuare alcune forme normali canoniche.

        \begin{defbox}{Forma Normale Disgiuntiva}{}
            Diciamo che \( A \) è in Forma Normale Disgiuntiva (\textbf{DNF}, \textit{Disjunctive Normal Form}) se \( A \) è una disgiunzione di congiunzioni di letterali, ossia è nella forma seguente:

            \[ \bigvee_{i\leq n} \bigwedge_{j\leq m_i} A_{ij} = (A_{1,1} \land \dots \land A_{1, m_1}) \lor \dots \lor (A_{n,1} \land \dots \land A_{n, m_n}) \]

        \end{defbox}

        \begin{defbox}{Forma Normale Congiuntiva}{}
            Diciamo che \( A \) è in Forma Normale Congiuntiva (\textbf{CNF}, \textit{Conjunctive Normal Form}) se \( A \) è una disgiunzione di congiunzioni di letterali, ossia è nella forma seguente:

            \[ \bigwedge_{i\leq n} \bigvee_{j\leq m_i} A_{ij} = (A_{1,1} \lor \dots \lor A_{1, m_1}) \land \dots \land (A_{n,1} \lor \dots \lor A_{n, m_n}) \]

        \end{defbox}

        \section{Equivalenza Logica}

        \begin{defbox}[colframe=PineGreen, colback=DeepGreenLight]{Equivalenza logica}{}
            Due formule \( A, B \in \text{PROP} \) sono logicamente equivalenti (\( A \equiv B \)) quando, per ogni assegnamento \( \alpha \) si ha \( \alpha(A) = \alpha(B) \).
        \end{defbox}


        Introduciamo alcune regole utili per verificare l'equivalenza tra proposizioni.

        Con un piccolo abuso di notazione, definiamo \( 1 \) e \( 0 \) come le formule per cui \( \forall \alpha, \ \alpha(1)= 1 \) e \( \alpha(0) = 0 \).

        In questo modo, abbiamo:

        \begin{table}[H]
            \centering
            \renewcommand{\arraystretch}{1.3}
            \begin{tabular}{|l|l|}
                \hline
                \textbf{Involuzione} & $\neg\neg A \equiv A$ \\
                \hline
                \textbf{Assorbimento (con 0 e 1)} &
                $A \lor 0 \equiv A$ \\
                                                  & $A \land 1 \equiv A$ \\
                                                  \hline
                \textbf{Cancellazione} &
                $A \lor 1 \equiv 1$ \\
                                       & $A \land 0 \equiv 0$ \\
                                       \hline
                \textbf{Terzo escluso (\textit{tertium non datur})} &
                $A \lor \neg A \equiv 1$ \\
                                                                    & $A \land \neg A \equiv 0$ \\
                                                                    \hline
                \textbf{Leggi di De Morgan} &
                $\neg(A \lor B) \equiv \neg A \land \neg B$ \\
                                            & $\neg(A \land B) \equiv \neg A \lor \neg B$ \\
                                            \hline
                \textbf{Commutatività} &
                $A \lor B \equiv B \lor A$ \\
                                       & $A \land B \equiv B \land A$ \\
                                       \hline
                \textbf{Associatività} &
                $A \lor (B \lor C) \equiv (A \lor B) \lor C$ \\
                                       & $A \land (B \land C) \equiv (A \land B) \land C$ \\
                                       \hline
                \textbf{Distributività} &
                $A \lor (B \land C) \equiv (A \lor B) \land (A \lor C)$ \\
                                        & $A \land (B \lor C) \equiv (A \land B) \lor (A \land C)$ \\
                                        \hline
                \textbf{I teorema di assorbimento} &
                $A \lor (A \land B) \equiv A$ \\
                                                   & $A \land (A \lor B) \equiv A$ \\
                                                   \hline
                \textbf{II teorema di assorbimento} &
                $A \lor (\neg A \land B) \equiv A \lor B$ \\
                                                    & $A \land (\neg A \lor B) \equiv A \land B$ \\
                                                    \hline

            \end{tabular}
            \caption{Principali leggi di equivalenza logica}
        \end{table}

        \section{Formalizzazioni in logica proposizionale}

        Il concetto di soddisfacibilità ci permette di usare insiemi di formule proposizionali per catturare determinate strutture matematiche.

        Per esempio: sia \( X \) un insieme. Consideriamo il linguaggio proposizionale composto dalle variabili \(p_{(x, y)}  \) per ogni \( (x,y) \in X \times X\), e consideriamo il seguente insieme \( T \) di proposizioni in questo linguaggio:

        \begin{enumerate}
            \item \( \neg p_{x,x} \ \ \forall x \in X\) \ {\color{gray}(antiriflessività)}
            \item \( p_{x, y} \to \neg p_{y,x} \ \   \forall x \in X\) \ {\color{gray}(asimmetria)}
            \item \( (p_{x, y} \land p_{y, z}) \to p_{x, z} \ \ \forall x, y, z \in X\) \ {\color{gray}(transitività)}
            \item \( (p_{x, y} \land p_{y, z}) \to p_{x, z} \  \ \forall x, y, z \in X\) \ {\color{gray}(ordine totale)}
        \end{enumerate}

        L'insieme \( T = T_X \) esprime il concetto di \textbf{ordine totale stretto} su \( X \). Infatti, se avessimo un assegnamento \( \alpha \) che soddisfa tutte le proposizioni di \( T \), l'ordine indotto da tutte le variabili vere sotto \( \alpha \) sarebbe un ordine totale stretto di \( X  \).

        Se \( \alpha \) è un assegnamento, definiamo la relazione \( \prec_{\alpha} \) su \( X \) come segue:
        \[ x \prec_\alpha y \leftrightarrow \alpha(p_{x,y})=1 \]

        Si ha che per ogni assegnamento \( \alpha \) che soddisfca \( T_X \), l'ordine \( \prec_\alpha \) indotto da \( \alpha \) è un ordine totale stretto su \( X \).

        Dall'altra parte, se \( \prec \) è un ordine totale stretto su \( X \), e \( \alpha_\prec \) è l'assegnamento indotto da \( \prec \) così definito:
        \[ \alpha_\prec (p_{x,y}) = 1 \leftrightarrow (x \prec y) \]

        Si ha che, per ogni ordine totale stretto \( \prec \) su \(X \), l'assegnamento \( \alpha_\prec \) indotto da \( \prec \) sulle variabili \( p_{x, y} \) soddisfa \( T \).

        Ovvero, un assegnamento \( \alpha \) soddisfa la teoria \( T_X \) se e solo se l'ordine indotto da \( \alpha \) su \( X \) è un ordine totale.

        \begin{gbox}{Colorabilità}
            
        \end{gbox}





        \end{document}
